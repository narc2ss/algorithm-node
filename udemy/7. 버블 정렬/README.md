## 선수 학습

1. 빅오 표기법

---

## 정렬 알고리즘 소개

정렬 알고리즘은 컬렉션(collection)의 항목을 재배열 하는 과정을 의미한다.

어떤 배열이 있다고 가정하고 우리는 배열을 인자로 전달받고 기록된 배열을 반환하는 함수를 작성하려고 한다.

- 숫자를 오름차순이나 내림차순으로 정렬
- 이름을 알파벳 순으로 정렬
- 영화를 개봉연도 순으로 정렬

여기서 핵심은 무엇을 어떻게 비교해서 정렬하는지는 중요하지 않다는 것이다.

알파벳을 기준으로 하든, 숫자를 기준으로 하든, 내림차순이든, 오름차순이든 상관없다. 지금은 배열과 숫자에 집중할 것이다.

sort라는 함수를 작성해야 한다면 이 함수는 배열을 인자로 전달받고, 정렬된 배열을 반환해야 한다.

```jsx
function sort(arr) {}
sort([23, 45, 6, 12, 13]); // [6, 12, 14, 23, 45]
```

딱히 어려워 보이지 않다. 하지만 정렬을 수행하는 방법은 무수히 많다. 그것이 문제이며 정렬 알고리즘이 무섭게 느껴지는 이유는 현존하는 유명 알고리즘을 15개나 떠올릴 수 있기 때문이다.

실제로 이름이 있고, 널리 알려진 편이며, 완전히 똑같은 작업을 수행한다.

그 중 몇가지는 확실히 전반적으로 다른 알고리즘보다 더 뛰어난데, 나중에 학습할 것이다.

또한 극소수의 경우에만 사용하는 알고리즘도 존재하는데. 대부분의 경우에는 성능이 최악이지만 특정 상황에서는 훌륭하게 작동한다.

### 왜 배워야 할까?

- 정렬이 프로그래밍에서 정말로 흔하게 사용되기 때문
- 데이터를 정렬하는 방법은 많고, 각 알고리즘에는 장단점이 있기 때문 [Sorting Algorithms Animations](https://www.toptal.com/developers/sorting-algorithms)

### 목표

- 버블 정렬
- 선택 정렬
- 삽입 정렬

> 이 세가지는 기본적인 정렬 알고리즘이며, 효율성이 떨어지기때문에 흔히 사용되지 않지만 그렇다고 배우지도 말아야 하는 것은 아니다.

- 기본적인 정렬 알고리즘이 중요한 이유

---

## 기본 내장 자바스크립트 정렬

기본적인 정렬 알고리즘을 학습하기 앞서 자바스크립트의 내장 정렬 메소드를 다루어 본다.

자바스크립트의 모든 배열에는 내장 정렬 메소드가 있다. 하지만 정렬 메소드가 항상 예상대로 작동하지는 않는다.

```jsx
["Steele", "Colt", "Data Structures", "Algorithms"].sort();
// ["Algorithms", "Colt", "Data Structrues", "Steele"]
```

위 예시는 A로 시작하여 Z로 끝나기 때문에 올바른 동작이라고 생각이 된다.

```jsx
[6, 4, 15, 10].sort();
// [10, 15, 4, 6]
```

위의 경우는 결과가 논리적이지 않다.

MDN에서 문서를 확인해 보면 `sort` 의 기본 정렬 순서는 문자열 유니코드(Unicode) 코드 포인트에 따른다고 나와있다.

따라서

1. 배열의 모든 항목이 문자열로 변환된다.
2. 해당 문자열의 유니코드 값이 선택되고 그 다음에 항목이 정렬된다.

굉장히 이상하다. 애초에 문자열로 정렬을 시작하지 않는 한 원하는 결과를 얻는게 불가능에 가깝다.

`sort` 메소드를 어떻게 사용할까?

정렬 방식, 정렬의 기준이 되는 속성, 비교 대상을 실제로 지정할 수 있다면 원하는 결과를 낼 수 있다.

- 내장 정렬 메소드는 선택적 비교함수(Optional comparator function)를 인자로 전달받는다.
- 이 함수를 사용해서 자바스크립트에 우리가 원하는 정렬 방식을 알릴 수 있다.
- 이 함수는 A와 B라는 2개의 항목이 있는 구조로 작성하며 반환되는 값을 토대로 만들 정렬 순서를 자바스크립트에 알린다.
  - **음수를 반환**하면, 자바스크립트는 **a가 b앞**에 온다고 결정할 것이다.
  - **양수를 반환**하면, 자바스크립트는 **b가 a앞**에 온다고 결정할 것이다.
  - **0을 반환**하면, 자바스크립트는 **a와 b를 동일하게 취급**하고 한꺼번에 정렬한다.

```jsx
[6, 4, 15, 10].sort((a, b) => a - b);
// [4, 6, 10, 15]
```

이제 나머지 시간에는 실제로 비교를 수행하는 정렬 알고리즘을 작성하는데 집중할 것이다.

---

## 버블 정렬

버블 정렬은 별로 효육적이지도 않고 흔히 사용되지도 않는다.

버블 정렬이 두각을 나타내는 분야에 대해서는 추후에 언급하겠지만, 보통은 버블 정렬을 배우지 않는다.

다른 알고리즘이 버블 정렬보다 더 나은 이유를 이해하는데 도움이 된다. ([알고리즘을 시각적으로 볼 수 있다](https://visualgo.net/en))

버블 정렬의 개념은 배열을 가장 작은 숫자에서 가장 큰 숫자순으로(오름차순), 정렬을 한다면 더 큰 숫자가 한 번에 하나씩 뒤로 이동을 한다는 것이다.

버블 정렬의 작동 방식은 루프를 돌면서 각 항목을 다음 항목(오른쪽에 있는 항목)과 비교하는 것이다. 다음 항목(비교 대상)이 더 크다면 교환(swap)을 한다.

교환은 버블정렬의 작동 원리에 정말 중요한 부분이다.

이렇게 첫 번째로 배열 끝까지 버블 정렬을 실행했다면 가장 큰 원소가 배열의 끝에 위치하게 된다.

버블 정렬을 싱킹 정렬(sinking sort)이라고도 하는데, 이 경우에는 가장 큰 값이 왼쪽 끝으로 간다.

이렇게 계속 반복하기만 하면 된다.

기억해야 할 점은 반복을 거듭함에 따라서 정렬해야 하는 항목의 수가 감소한 다는 것이다.

그전에, 아주 중요한 교환(swap)에 대해 알아보자.

자바스크립트에는 몇 가지 교환 방법이 있다.

```js
// ES5
function swap(arr, idx1, idx2) {
  let temp = arr[idx1];
  arr[idx1] = arr[idx2];
  arr[idx2] = temp;
}

// ES6
const swap = (arr, idx1, idx2) => {
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
};
```

두 개의 함수는 정확히 같은 동작을 한다.

### 의사 코드

- 숫자 배열을 인자로 받는 bubbleSort라는 함수를 정의한다.
- 처음부터 끝까지 i라는 변수로 루프를 시작한다.
- 처음부터 i - 1까지 j라는 변수로 내부 루프를 시작한다.
- arr[j]가 arr[j+1]보다 크다면 두 값을 swap한다.
- 반복이 끝났다면 배열을 반환한다.

---

## 버블 정렬 : 구현

### 내가 시도한 코드

```js
function bubbleSort(arr) {
  let temp;
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

console.log(bubbleSort([37, 45, 29, 8])); // [ 8, 29, 37, 45 ]
```

### 솔루션

```js
function bubbleSort(arr) {
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };

  for (let i = arr.length; i > 0; i--) {
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) swap(arr, j, j + 1);
    }
  }
  return arr;
}

console.log(bubbleSort([37, 45, 29, 8])); // [ 8, 29, 37, 45 ]
```

---

## 버블 정렬 : 최적화

버블 정렬시 데이터가 거의 정렬이 된 상태이거나 이미 정렬이 완료됐다면, 버블 정렬을 할 필요가 없다.

위의 경우 정렬이 되었지만 코드는 계속 실행될 것이다.

만약에 배열의 길이가 길다면 긴 소요시간으로 인하여 문제가 될 것이다.

만약 루프가 마지막으로 실행되었을 때 swap을 했는가를 판단하여 정렬이 완료되었는지 알 수 있다.

교환을 하지 않았다면, 다음번에도 교환을 하지 않을 것이기 때문이다.

```js
function bubbleSort(arr) {
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };

  let noSwap = true;
  for (let i = arr.length; i > 0; i--) {
    noSwap = true;
    for (let j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
        noSwap = false;
      }
    }

    if (noSwap) break;
  }
  return arr;
}

console.log(bubbleSort([37, 45, 29, 8])); // [ 8, 29, 37, 45 ]
```
