## 선수 학습

1. 빅오 표기법
2. 재귀
3. 버블 정렬
4. 선택 정렬
5. 삽입 정렬

---

## 기가 막히게 빠른 정렬 소개

중급 정렬 알고리즘에는 살펴볼 것이 세 가지가 더 있는데 각각 따로 학습할 것이다.

더 빠르지만, 조금 더 어렵기 때문이다. 직접 코드를 작성하기에는 직관적이지 않다.

알차고 매력적인 알고리즘으로 이해하는 데 시간이 더 많이 걸린다.

하지만 더 빠르다는 보상이 있다.

중요한 이야기를 하고 싶은데, 두려워하지 말라.

처음이라면 코드를 직접 작성해야 한다는 부담을 느끼지않아도 된다.

직접 시도하고 구현해 보려는 모험적인 사람을 위해 의사코드를 제공하겠다.

하지만 이 섹션은 코드를 살펴보고 작동 방식을 이해하며 알고리즘을 설명할 수 있도록 다루며, 첫 번째 시도부터 코드를 작성할 능력을 기르려는 목적은 아니다.

### 목표

- 지금까지 학습한 알고리즘의의 한계를 이해한다.
- 합병 정렬을 구현한다.
- 퀵 정렬을 구현한다.
- 지수 정렬을 구현한다.

### 왜 배우는가?

- 지금까지 학습한 정렬 알고리즘은 큰 규모에 맞지 않다.
- 꽤 빠르게 작동하지만 10만개의 요소로 작업하는 경우 잘 적용되지 않는다.

### 빠른 정렬

- 앞으로 배울 알고리즘 집합은 시간 복잡도를 O(n^2)에서 O(n \* log n)으로 향상시킬 수 있다.
- 효율성과 단순성은 상충된다. 그래서 더 어렵고 더 길며, 코드가 길지 않더라도 더 이상하다.
- 그래서 이해하는 데 시간이 더 걸리지만, 그럴만한 가치가 있다.

---

## 합병 정렬 : 소개

합병 정렬은 1948년에 컴퓨터 과학자이자 수학자, 폰 노이만이 최초의 합병 정렬 프로그램을 작성했다.

에디악이라고 하는 컴퓨터에 사용하는 23페이지 짜리 코드였다. 당시 6천개 정도의 진공관을 사용했다.

- 합병 정렬을 뒷받참하는 개념을 실제로 합병과 정렬이라는 두 가지 조합으로 이루어져 있다. (사실 분할, 정렬, 합병으로 세가지가 일어난다.)
- 1개 또는 0개 요소를 가진 배열은 이미 정렬되어 있다는 점을 활용한다.
- 배열을 더 작은 배열로 나누는 분할 정복 알고리즘이다.

---

## 배열 합병 : 구현

합병 정렬에서 필요한 merge는 2개의 배열을 받아 정렬된 1개의 배열을 출력하는 함수이다.

의사코드는 다음과 같다

- 빈 배열을 만들고 각각의 배열의 원소중 작은 값을 먼저 빈 배열에 추가한다.
- 배열에 원소가 없을 때 까지 반복한다.
  - 첫 번째 배열의 값이 두 번째 배열의 값보다 작은 경우 첫 번째 배열의 값을 결과에 푸시하고 첫 번째 배열의 다음 값으로 이동한다.
  - 첫 번째 배열의 값이 두 번째 배열의 값보다 큰 경우 두 번째 배열의 값을 결과에 푸시하고 두 번째 배열의 다음 값으로 이동한다.
  - 두 개의 배열 중 한개의 배열이 끝났다면 남은 배열의 값을 푸시한다.

```js
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;

  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }

  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }

  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }
  return results;
}

console.log(merge([1, 2, 3], [7, 8, 9])); // [ 1, 2, 3, 7, 8, 9, ]
```

---

## 합병 정렬 작성하기 1부

이제 합병 정렬의 정렬 부분이다. 그리고 코드 자체는 꽤 짧다.

문제는 개념적으로 조금 이해하기 어렵다는 것이다.

대부분의 합병 정렬 구현시 재귀를 사용하기 때문이다.

### 합병 정렬의 의사코드

- 배열의 원소가 하나 또는 없을 때 까지 배열을 나눈다.
- 전체 길이의 배열을 가질 때 까지 합병 함수를 사용해 다시 합친다.
- 배열을 다시 합쳤으면 가장 마지막에 합병된 배열을 반환한다.

---

## 합병 정렬 작성하기 2부

```js
function merge(arr1, arr2) {
  let results = [];
  let i = 0;
  let j = 0;

  while (i < arr1.length && j < arr2.length) {
    if (arr2[j] > arr1[i]) {
      results.push(arr1[i]);
      i++;
    } else {
      results.push(arr2[j]);
      j++;
    }
  }
  while (i < arr1.length) {
    results.push(arr1[i]);
    i++;
  }
  while (j < arr2.length) {
    results.push(arr2[j]);
    j++;
  }
  return results;
}

function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  return merge(left, right);
}

console.log(mergeSort([8, 1, 6, 2, 36, 82, 34])); // [ 1, 2, 6, 8, 34, 36, 82 ]
```

---

## 합병 정렬을 위한 빅오 복잡도

합병 장렬의 시간 및 공간 복잡도인 빅오에 대해서 알아보자

| Time Complexity (Best) | Time Complexity (Average) | Time Complexity (Worst) | Space Complexity |
| ---------------------- | ------------------------- | ----------------------- | ---------------- |
| O(n log n)             | O(n log n)                | O(n log n)              | O(n)             |

`O(n)`은 merge를 수행하는데 걸리는 시간 복잡도이며 `O(log n)`은 배열을 분할하는데 걸리는 시간 복잡도이다.

따라서 합병 정렬에서는 최적 케이스, 평균 케이스, 가장 나쁜 케이스가 `O(n log n)`으로 모두 같다.

공간 복잡도는 배열이 클 수록 합병 정렬에서는 메모리에 더 많은 배열을 저장해야한다.
