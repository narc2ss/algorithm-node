## 선수 학습

1. 빅오 표기법
2. 버블 정렬
3. 선택 정렬

---

## 삽입 정렬 : 소개

삽입 정렬을 버블 정렬 및 선택 정렬과 꽤 비슷하다. 그러나 몇 가지 주요 차이점이 있고, 삽입 정렬이 잘 작동하는 상황이 있다.

삽입 정렬은 배열의 과반을 점차적으로 만들어 정렬을 구축하며, 과반은 항상 정렬되어 있다.

따라서 하나씩 이동하거나, 한 번에 가장 큰 요소나 작은 요소를 찾는 대신 각 요소를 취하여 정렬되어 있는 절반 속 해당되는 위치에 배치한다.

### 의사코드

- 배열에서 두 번째 요소를 선택하여 시작한다. 첫 번째 요소는 정렬되었다고 간주하기 때문
- 두 번째 값을 취해서 앞에 있는 값과 비교한다. 그리고 필요하다면 바꾼다.
- 옆의 요소로 계속하여 올바른 위치에 있는지 확인한다. 정렬된 부분을 거치며 반복한다.
- 배열을 정렬할 때까지 반복한 다음 배열을 반환한다.

### 내가 시도한 코드

```js
function insertionSort(arr) {
  let j, temp;
  for (let i = 1; i < arr.length; i++) {
    j = i;
    while (arr[j] < arr[j - 1]) {
      temp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = temp;
      j--;
    }
  }

  console.log(arr);
  return arr;
}

insertionSort([5, 4, 3, 2, 1]); // [1, 2, 3, 4, 5]
```

---

## 삽입 정렬 : 구현

```js
function insertionSort(arr) {
  for (var i = 1; i < arr.length; i++) {
    var currentVal = arr[i];
    for (var j = i - 1; j >= 0 && arr[j] > currentVal; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = currentVal;
  }
  console.log(arr);
  return arr;
}

insertionSort([2, 1, 9, 76, 4]); // [ 1, 2, 4, 9, 76 ]
```

---

## 삽입 정렬 : 빅오 복잡도

삽입 정렬의 시간 복잡도는 버블 정렬과 선택 정렬 두 가지와 전반적으로 비슷하다.

가장 좋지 않은 경우인 O(n^2)의 경우 2차 식이 되는데 배열의 길이가 늘어날 수록 비교 횟수를 기본적으로 n 제곱해야 하기 때문이다.

데이터가 정렬되어 있는 경우라면 삽입 정렬이 유리하다.

삽입 정렬이 유리한 상황은 온라인 알고리즘이라는 데이터가 있는 경우다.

데이터가 들어오는 대로 작동하는 알고리즘으로 새로운 데이터를 수진하므로 전체 배열을 한 번에 정렬할 필요가 없다.

예를들어, 온라인에서 실시간으로 번호를 제출하는 코드가 있다고 가정해보자.

삽입 정렬은 한 부분을 정렬된 배열로 유지하고 한 번에 항목을 삽입하여 작동하기 때문에 어떤 숫자가 입력되더라도 필요한 위치에 놓을 수 있다.

라이브, 스트리밍 방식으로 들어오는 데이터를 즉시 입력해야 하는 상황에 편리하다.
